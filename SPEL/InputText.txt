//comentariu (programul vid da eroare)
int x;
functie(a);
/**/
//comentariul vid
//
/*comentariul
pe mai
multe linii
*/

//definitia clasei
/* 
//aceasta trebuie sa dea eroare daca este documentata
begin class clasa1 
end
*/
//clasa cu variabile
begin class clasa2
	int a;
	float b[];
	char c='\n';
	string d="string";
//	const int e;
	const char f=4;
//	const float vec[]=[1,4.5];
	const float vec[5]=[1,4.5];
end
//clasa cu functii
begin class clasa2
//	begin int functie_clasa2() end;
//	functia vida da eroare
	begin void functie2() 
		char sir[]=['1', 'a', 2, '\4'];
	end
	begin void functie_void_cu_return()
//		return 4;
		float c=1.1;
	end
	//in declaratii la functii const nu trebuie sa fie initializat
	begin string functie_cu_return (string a, const char b[]) 
		return b[3];
//		const float vec[]=[1,4.5];
		const float vec[5]=[1,4.5];
	end
end
//clasa cu functii si variabile
//clasa cu functii
begin class clasa3
	begin void functie2() 
		char sir[]=['1', 'a', 2, '\4'];
	end
	int x;
	begin void functie_void_cu_return()
		float c=1.1;
	end
	bool variabila[]=[true, false];
end
const int _a=1;
functie(a);
/*
//asta de mai jos nu are sa mearga pana nu primeste suport pentru . si este facut eval_expr
functie(a+obj.a);
*/
//		Se pare ca daca avem un comentariu care nu are ENTER la final da eroare. Nu vad cum s-ar putea evita acest lucru



//test3
int a = 1;
float b = c;
float d = 1.0;
char v = 'a';
string str = "a";
bool bolean[] = [true, false]; 
//test4
begin int man(int a, int b) 
	return a+b*3;
end
//test5
begin class clasa1
	int a, c;
	float b;
	char v;
	string str;
	bool bolean;
	begin int max(int x1, int x2)
	/*daca exista begin&end la functie nu prea are sens sa facem declaratia functiei fara nimic in ea.
		return x1;
	end
end
//test6
clasa1 obj;
//test7
int a1[];
/*modificat declaratiile de la vector, le-am facut la fel ca declaratia de mai sus, sa fie consistenta */
float b1[];
char v1[];
string str1[];
bool bol1[];
clasa1 obj1[];

//test8
const int kst1=1;
const float kst2=1.1;
const char kst3=5;
const string kst4="kst4";
const int vkst[3] =[1, 3, 1]; //declarare size la const? 
begin float functie(int a) return 1; end



//if-ul nu merge cu parametru in interior deoarece eval_expr este vida
if () beginif
	functie(1);
endif
else beginelse
	functie(1);
endelse



//	Astea cu plus , minus, si alte semne nu merg
//functie(a+obj.a);
//functie(man(1+3));
functie(45);
//functie(3+4);
functie(kst1);

while ()
	
	string str1[1]=[3];
	functie(45);

endwhile

begin int functie ()
	b=;
	str=;
end

for (x in 1:30) //for (int x=1; x<=30; x++)
	int b;
endfor
for (x in str1) //for (auto:x in str1) - 
	char f=4;
	functie(4);
	b=;
//aici sintaxa va fi for x in variabila, nu trebuie facuta validare decat ca partea dreapta este fie variabila fie string
//daca variabila va fi string validarea se va face la semantic
endfor